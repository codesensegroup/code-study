{"_path":"/clean-arch/chapter13","_dir":"clean-arch","_draft":false,"_partial":false,"_locale":"","title":"13 元件內聚性","description":"哪個類別該屬於哪個元件? 讓我們來看看元件的 內聚性。","pageTitle":"Chapter 13 元件內聚性","contributors":["frank30941"],"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"哪個類別該屬於哪個元件? 讓我們來看看元件的 "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"內聚性"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"元件可以從一個 library 或是一個 micro service 角度去理解 (by yohuan)。"}]},{"type":"element","tag":"h2","props":{"id":"rep-reuserelease-equivalence-principle-再使用性-發布等價原則"},"children":[{"type":"text","value":"REP (Reuse/Release Equivalence Principle) 再使用性-發布等價原則"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"再使用性的細微度就是發布的細微度。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在過去十年裡，已經流行起模組管理工具，幫助我們建立大量可重用的元件以及元件庫。而透過可追蹤的發布程序以及相對應的版本編號，使我們可以重用軟體元件。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"發布程序必須產生適當的通知以及文件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"讓使用者可以決定何時以及是否要整合新版本"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"從架構的角度來看，組成一個元件的類別和模組必須是一個有內聚力的的群組。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"組合到一個元件中的類別和模組應該被一起發布"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"共享著相同的版號、相同的版本文件"}]}]},{"type":"element","tag":"h2","props":{"id":"ccp-common-closure-principle-共同封閉原則"},"children":[{"type":"text","value":"CCP (Common Closure Principle) 共同封閉原則"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"將那些會因著相同理由、在相同時間發生變化的類別收集到相同的元件之中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如同 SRP 規定一個類別不應該包括多個引起變化的原因; CCP 也規定一個元件不應該包含多個引起變化的原因。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果兩個類別不管在物理上或是概念上有綁定關係，總是一起變化，那他們應該屬於同一個元件。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大多數形況下，可維護性大過可重用性，如果一個應用程式需要更改，那我們希望更改都集中在單一的元件當中，而不是分散在各地。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"僅需要重新部署更改的元件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"剩下的不用重新驗證以及部署"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如此一來，當需求來臨時，我們將變化盡可能的限制在最小數量的元件當中。"}]},{"type":"element","tag":"h2","props":{"id":"crp-common-reuse-principle-共同重復使用原則"},"children":[{"type":"text","value":"CRP (Common Reuse Principle) 共同重復使用原則"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"不要強迫元件的使用者依賴他們不需要的東西。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"換句話說，要將傾向於一起使用的類別和模組放入同一元件當中"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ex: 一個容器類別和其 iterator 應該放在同一元件當中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如同 ISP 所言，我們不要依賴我們未使用的東西。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當一個元件使用另一個元件時，之間會建立一個依賴關係，也許只使用其中一個小類別，也無法消除這種依賴關係，每當依賴的元件發生變更時，使用的元件可能要"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"做出相對應的修改"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"或是重新編譯、驗證、部署"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"即使是我們沒使用到的小類別發生修改，我們依然無法避免。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這個原則除了告訴我們那些類別該放入相同元件裡，更告訴我們哪些類別 不要 放入相同元件裡。"}]},{"type":"element","tag":"h2","props":{"id":"內聚性的張力圖"},"children":[{"type":"text","value":"內聚性的張力圖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述三個內聚性原則像是在互相拉扯。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"REP 和 CCP 是 包容性 原則，傾向使元件變得更大。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CRP 是個 排除性 原則，傾向使元件變得更小。"}]}]},{"type":"element","tag":"div","props":{"align":"center"},"children":[{"type":"text","value":"\n  "},{"type":"element","tag":"img","props":{"src":"/code-study/images/clean-arch/13/01.png","width":"90%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"架構師必須要在這個張力圖當中，找到團隊當前該關注的位置，並隨時做改變。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通常專案的開始會在圖的右側，也就是會犧牲 重用性，隨著時間慢慢往左移動。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假設在開發串接shopee的"},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"元件"}]},{"type":"text","value":"時"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hard to reuse:\n"},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一開始會先考慮時程，而放棄版號控制，並把不同業務邏輯的類別放在一起加速開法，這會導致使用"},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"元件"}]},{"type":"text","value":"的開發者不能鎖定版號，如遇到破壞性變更，將導致服務不可用的情況發生。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Too many unneeded releases:\n"},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因為發生多次不可用的情況，這時候加入版號控制，來因應需求的增長，因為未切割不同業務邏輯的類別，所以修改或增加一個類別就要增加版號，將導致多次不必要增加版號的發布。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Too many components change:\n"},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"專案趨向於穩定，也重新規劃"},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"元件"}]},{"type":"text","value":"，切割成多個不同業務邏輯的"},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"元件"}]},{"type":"text","value":"，如 Auth Product Order...，但當Shopee更改Token驗證方式時，將導致對多個"},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"元件"}]},{"type":"text","value":"做修改，增加開發時程。"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"conclusion"},"children":[{"type":"text","value":"Conclusion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"過去，我們對於內聚性只認為 "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"一個模組只能執行一個功能"}]},{"type":"text","value":"，然而我們在選擇類別組成元件時，必須考慮到可重用性和可發展性的相對力量，並隨時保持動態平衡。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"rep-reuserelease-equivalence-principle-再使用性-發布等價原則","depth":2,"text":"REP (Reuse/Release Equivalence Principle) 再使用性-發布等價原則"},{"id":"ccp-common-closure-principle-共同封閉原則","depth":2,"text":"CCP (Common Closure Principle) 共同封閉原則"},{"id":"crp-common-reuse-principle-共同重復使用原則","depth":2,"text":"CRP (Common Reuse Principle) 共同重復使用原則"},{"id":"內聚性的張力圖","depth":2,"text":"內聚性的張力圖"},{"id":"conclusion","depth":2,"text":"Conclusion"}]}},"_type":"markdown","_id":"content:6.clean-arch:13.chapter13.md","_source":"content","_file":"6.clean-arch/13.chapter13.md","_extension":"md"}