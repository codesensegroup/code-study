---
title: 'Chapter 03 數據儲存與檢索'
description: 'Chapter 03 數據儲存與檢索'
position: 295
category: 資料密集型應用系統設計
menuTitle: 'Chapter 03'
contributors: ['yulin0629']
---

# Designing Data-Intensive Applications Ch3

[ddia/ch3.md at master · Vonng/ddia](https://github.com/Vonng/ddia/blob/master/zh-tw/ch3.md)

## 引言

數據庫最基本兩件事：

- 儲存數據
- 檢索數據

本章會討論

- 資料庫如何儲存資料
- 如何找到資料

儲存引擎依據負載進最佳化，分成兩種

- 事務型負載最佳化
    
    Online Transaction Processing (OLTP) 儲存引擎，用於高併發的交易性應用，需要支援併發的讀取或寫入操作。
    
- 分析性負載最佳化
    
    Online Analytical Processing (OLAP) 儲存引擎，用於針對大數據集進行分析查詢，支援複雜的聚集計算和多維分析。
    

兩大類資料庫引擎

- page-oriented
    
    頁面導向資料庫被用於儲存表格，其中每個表格被分為好幾個磁碟頁面。磁碟頁面是資料庫系統與磁碟交互的最小單位，通常大小為 4KB 或 8KB。
    
- log-structured
    
    日誌導向資料庫最初是由 Google 發明，用於處理 Web 搜索的索引數據。這種資料庫引擎將所有修改操作寫入一個追蹤寫入（write-ahead log, WAL）中，然後將實際數據讀取到記憶體中，並在記憶體中進行修改。當修改完成時，這些修改操作會被追加到 WAL 中，然後再以某種方式寫入磁碟。這種方式允許寫入操作非常快速，並且可以維護良好的寫入吞吐量，從而使其成為許多大型分佈式數據庫的理想選擇。
    

## 驅動資料庫的資料結構

### 最簡單的資料庫

```bash
#!/bin/bash
db_set () {
  echo "$1,$2" >> database
}

db_get () {
  grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

這個簡單的程式實現鍵值儲存和讀取，每次set 時會在檔案尾巴追加記錄，讀取時會從最後一行往上找直到找到key

```powershell
$ db_set 123456 '{"name":"London","attractions":["Big Ben","London Eye"]}'

$ db_set 42 '{"name":"San Francisco","attractions":["Golden Gate Bridge"]}'

$ db_get 42
{"name":"San Francisco","attractions":["Golden Gate Bridge"]}
```

db_set 有非常好的效能，因為在檔尾追加寫入是非常高效的，許多資料庫的內部使用了log structed，也是用**僅追加(append-only)**

db_get 的效能則很糟, O(n)，為了改善這個問題，我們需要一個數據結構 Index

Index 是一個「額外」的資料，能改變查詢的效能，但是在寫入時會增加開銷，所以寫入效能很難超過單純的追加寫入檔案

權衡選什麼索引就是DBA的專業

### Hash Index

為了簡化，書中假設要儲存的資料是 key-value Data

假如資料要存進檔案，那 Index 最簡單的作法就是 存下每筆資料在檔案的 Offset

![Untitled](https://yulin0629.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F86c6b8c9-787a-4640-ab28-447704a99e97%2FUntitled.png?id=8746cde7-c082-45a5-9dce-f7eec4c009bf&table=block&spaceId=5dad317c-9e6b-4619-9d20-ed13b859e492&width=2000&userId=&cache=v2)

查詢資料時，只要從index取得 offset，再去檔案尋找(seek)即可。

感覺很簡單，實際上 Bitcask 就是這麼做的。

這種結構特別適合在很多寫操作的場景，像是貓咪影片的點擊次數

如果檔案太大的話，就開新的檔案，然後有時間再把舊的檔案壓縮

![健值更新日誌 (統計貓咪影片的播放次數)](https://yulin0629.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb8ab4a75-58e7-4e17-999a-ded4d39ede9b%2FUntitled.png?id=30e04d3f-81c4-4064-b9af-e25a7130ba2a&table=block&spaceId=5dad317c-9e6b-4619-9d20-ed13b859e492&width=2000&userId=&cache=v2)

健值更新日誌 (統計貓咪影片的播放次數)

檔案很多的話，可以合併

![**同時執行壓縮和分段合併**](https://yulin0629.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5be9dee5-0117-4dd0-aff5-b39e9c977a00%2FUntitled.png?id=fe447162-6fa9-4d2e-8f21-1798cb1470ec&table=block&spaceId=5dad317c-9e6b-4619-9d20-ed13b859e492&width=2000&userId=&cache=v2)

**同時執行壓縮和分段合併**

為每個檔案儲存自己的 hash index

其它實現細節：

- 檔案格式
    
    書中提到，在儲存數據時使用二進制格式會比使用文本格式更快，因為文本格式需要進行解析和序列化，而二進制格式可以直接使用。這是許多資料庫的優化技巧之一。
    
- 刪除記錄
    
    當資料被刪除時，為了避免 hash index 中的資料不一致，可以先標記它們為被刪除的狀態，稱為墓碑（tombstone）。當 hash index 查找到被標記為墓碑的資料時，就知道這個資料已經被刪除，並且不會再被回傳。
    
- 崩潰恢復
    
    如果資料庫重新啟動，因為記憶體中的雜湊對映表丟失，所以必須重新構建。這可以通過在啟動時重新讀取每個數據檔案並重建對映表來實現。Bitcask 會把 index cache 起來
    
- 部分寫入記錄
    
    資料庫隨時可能崩潰，包括在將記錄追加到日誌的過程中。 Bitcask 檔案包含校驗和，允許檢測和忽略日誌中的這些損壞部分。
    
- 併發控制
    
    由於寫操作是以嚴格的順序追加到日誌中的，所以常見的實現是隻有一個寫入執行緒。也因為資料檔案段是僅追加的或者說是不可變的，所以它們可以被多個執行緒同時讀取。
    

僅追加日誌似乎很浪費：為什麼不直接在檔案裡更新，原因如下

- 順序寫入比隨機讀取更快，因為它允許操作系統以更高效的方式編組寫入操作。
- 併發和崩潰恢復容易。
- 合併舊段資料可以防止碎片化問題

hash index 也有其侷限性：

- memory 放不下 index 時，hash index 在 disk 上表現很糟
- 範圍查詢效率不高，無法輕鬆掃描 kitty00000 ~ kitty99999

### SSTables and LSM tree

在之前的 hash index 結構，寫入檔案的 key 值順序，是照寫入時間先後的

SSTable(Sorted String Table) 則是要求寫入的順序照 key 的順序

用SSTable 的好處是

- 合併檔案可以更高效，同時讀取多個檔案合併
- 可以不用存下所有的 key offset 對應，因為 key 是排序的，只要先找到大概的位置，再掃描檔案即可
- index 的空間節省，IO也節省

![**具有記憶體索引的 SSTable**](https://yulin0629.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb9607c5e-3f8c-4fed-bf2b-a0b914646405%2FUntitled.png?id=4d8e3158-ec13-4a77-bf82-3cc8c15ed2f6&table=block&spaceId=5dad317c-9e6b-4619-9d20-ed13b859e492&width=2000&userId=&cache=v2)

**具有記憶體索引的 SSTable**

### **構建和維護SSTables**

如何讓資料能夠預先排好序呢？畢竟我們接收到的寫入請求是沒有順序的。

雖然在硬碟上維護有序結構也是可能的，但在記憶體內則容易多

方便排序的資料結構

- 紅黑樹
- AVL 樹

我們可以讓我們的儲存引擎以如下方式工作：

- 有新寫入時，將其新增到記憶體中的平衡樹資料結構。
- 當 **記憶體表** 大於某個閾值（通常為幾兆位元組）時，將其作為 SSTable 檔案寫入硬碟。當該 SSTable 被寫入硬碟時，新的寫入可以在一個新的記憶體表例項上繼續進行。
- 收到讀取請求時，首先嘗試在記憶體表中找到對應的鍵，如果沒有就在最近的硬碟段中尋找，如果還沒有就在下一個較舊的段中繼續尋找，以此類推。
- 時不時地，在後臺執行一個合併和壓縮過程，以合併段檔案並將已覆蓋或已刪除的值丟棄掉。

只剩一個問題，資料庫崩潰，則最近的寫入（在記憶體表中，但尚未寫入硬碟）將丟失。

解法：硬碟上儲存一個單獨的日誌檔，在寫入記憶體錢先寫入日誌檔，用於崩潰後回復記憶體

### **用SSTables製作LSM樹**

LSM-Tree（Log Structured-Merge Tree）是一種非常流行的樹型資料結構，用於實現許多現代資料庫系統。LSM-Tree 將數據分為多個層，每層使用不同的資料結構（如 SSTable）來進行儲存和檢索。當資料寫入時，它會先被寫入具有較快寫入速度的記憶體中，然後當記憶體中的資料達到一定閾值時，會將其寫入下一層。這樣可以避免過多的硬碟寫入，同時也可以提高查詢效率。

![Untitled](https://yulin0629.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff20b5584-f445-46f7-986f-7cade85ecfca%2FUntitled.png?id=7e025598-e2a1-4c72-a81c-604a9a8f189e&table=block&spaceId=5dad317c-9e6b-4619-9d20-ed13b859e492&width=1440&userId=&cache=v2)

****LSM Read 實作方式****

在 LSM-Tree 中，當我們需要查詢資料時，會首先在記憶體中查找，如果找不到，就繼續在下一層的 SSTable 中查找，直到找到該筆資料或者所有的 SSTable 都被查詢過為止。此外，LSM-Tree 通常還會使用 Bloom Filters 來進一步加速查詢。

Bloom Filters 是一種資料結構，常用於判斷某個元素是否存在於一個集合中。它是由 Burton Bloom 於 1970 年提出的。

相較於傳統的B-Tree，LSM-Tree的優點在於：

- 寫入效率高，因為數據先被寫入記憶體中，而不是直接寫入磁碟中，當記憶體中的數據達到一定閾值時，再進行一次性的寫入操作。
- 可以進行批量寫入和刪除操作，因為數據被分為多個層，可以使用批量寫入和刪除操作來進行優化。
- 可以進行崩潰恢復，因為數據被分為多個層，可以在數據崩潰時進行恢復操作。

LSM-Tree 的缺點包括：

- 查詢效率不穩定，因為數據被分為多個層，所以查詢效率可能會隨著層數的增加而下降，尤其是在 SSTable 中有很多墓碑（tombstone）時。
- LSM-Tree 的儲存格式比較複雜，需要將數據分為多個層，每層使用不同的資料結構進行儲存，這導致它比較難以實現。
- 在寫入時，需要先將數據寫入記憶體中，然後再進行一次性的寫入操作。這樣會導致寫入操作的延遲性較高。

總體而言，LSM-Tree 是一種非常有效的數據儲存和檢索方式，但它也有一些缺點，需要在實際使用中加以注意。

### 效能最佳化

當查詢不存在的鍵時，需要檢查記憶體表和從最近到最早的所有段檔案，那樣很慢。

解決方法：

- 使用布隆過濾器(Bloom Filters)來最佳化查詢不存在的鍵時的訪問
- 考慮使用 size-tiered 和 leveled compaction 來確定 SSTables 被壓縮和合並的順序和時間

LSM 樹的基本思想是將一系列在後臺合併的 SSTables 儲存起來，即使資料集比可用記憶體大得多，它仍能繼續正常工作。資料按排序順序儲存，可高效地執行範圍查詢，並且因為硬碟寫入是連續的，所以 LSM 樹可以支援非常高的寫入吞吐量。

Bloom Filter（布隆過濾器）是用來檢驗一個元素是否存在於特定集合中的概念。它在空間複雜度方面比 hash table 更優秀，但使用它時需要注意偽陽性(false positive)的問題

false positive：沒有就是沒有，有代表有可能有

## B樹

日誌結構索引已經很常見，但它們不是最常用的索引。B 樹是一種最常見的索引結構，從 1970 年被引入以來，僅不到 10 年就變得“無處不在”，被廣泛使用在關係資料庫和非關係資料庫中。

像 SSTables 一樣，B 樹保持按鍵排序的鍵值對，這允許高效的鍵值查詢和範圍查詢。

B 樹將資料庫分解成固定大小的塊或分頁，通常大小為 4KB，並且一次只能讀取或寫入一個頁面。每個頁面都可以使用地址或位置來標識，這允許一個頁面引用另一個頁面，類似於指標，只是是在硬碟而不是在記憶體中。我們可以使用這些頁面引用來構建一個頁面樹，如圖 3-6 所示。

![**使用 B 樹索引查詢一個鍵**](https://yulin0629.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fde6faf53-f8dc-46ac-806f-678e67ff1124%2FUntitled.png?id=851b291a-c085-4e6b-9bd6-dbe75a28bf8c&table=block&spaceId=5dad317c-9e6b-4619-9d20-ed13b859e492&width=2000&userId=&cache=v2)

**使用 B 樹索引查詢一個鍵**

- B樹由根頁面、子頁面和葉子頁面組成
- 子頁面負責連續鍵範圍，根頁面上的鍵表示相鄰子頁面管理的鍵的邊界
- 查找鍵值時，從根頁面開始，按範圍查找子頁面，直到葉子頁面
- 分支因子是每個頁面中對子頁面引用的數量，範例上是6個，通常是幾百

![Untitled](https://yulin0629.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F40ddeb9e-8dcb-40ff-83b5-e1e3bc933469%2FUntitled.png?id=a11f05db-38f9-469d-a830-99db06972548&table=block&spaceId=5dad317c-9e6b-4619-9d20-ed13b859e492&width=2000&userId=&cache=v2)

- 更新 B 樹中的鍵值，需搜尋包含該鍵的葉子頁面，更改值，再將該頁面寫回硬碟（引用仍有效）。
- 新增鍵需找到可包含它的頁面，如空間不足，則分成兩半滿頁面，並更新父頁面。
- 演算法確保樹平衡，n 個鍵的 B 樹深度為 O(log n)。多數資料庫可用三到四層樹，分支因子為 500 的 4KB 頁面的四層樹，可儲存 256TB 資料。

### 讓B樹更可靠

- B 樹的基本寫入操作，
- 如何覆寫硬碟上的頁面以及如何處理拆分頁面等情況。
- 討論了預寫式日誌（WAL）檔案以及併發控制的問題。
- 日誌結構化的方法相對於 B 樹的優勢。

B 樹的基本寫入操作是用新資料覆寫硬碟上的頁面，而不會改變頁面的位置。這表示當頁面被覆寫時，對該頁面的所有引用不會改變。這與日誌結構索引（如 LSM 樹）形成鮮明對比，後者只是追加到檔案，從不修改檔案中已有的內容。

覆寫硬碟上的頁面就像對實際硬體進行操作。在磁性硬碟驅動器上，這意味著將磁頭移動到正確的位置，等待旋轉盤上的正確位置出現，然後用新的資料覆寫適當的扇區。固態硬碟上，由於 SSD 必須一次擦除和重寫相當大的儲存晶片塊，因此會發生更複雜的事情。

有時候，需要覆寫多個不同的頁面。例如，因為插入導致頁面過滿而拆分頁面，則需要寫入新拆分的兩個頁面，並覆寫其父頁面以更新對兩個子頁面的引用。這是一個危險的操作，因為如果資料庫在系列操作進行到一半時崩潰，那麼最終將導致一個損壞的索引。

B 樹實現中通常會有預寫式日誌（WAL，即 write-ahead log，也稱為重做日誌）檔案，以處理異常崩潰的情況。每次對 B 樹的修改都必須先寫入該檔案，然後才能應用到樹本身的頁面。當資料庫在崩潰後恢復時，這個日誌將被用來使 B 樹恢復到一致的狀態。

當多個執行緒要同時訪問 B 樹時，還需要仔細的併發控制，否則執行緒可能會看到樹處於不一致的狀態。通常是透過使用鎖存器（latches，輕量級鎖）保護樹的資料結構來完成。日誌結構化的方法在這方面更簡單，因為它們在後臺進行所有的合併，不干擾新接收到的查詢，並且能夠時不時地將段檔案切換為新的（該切換是原子操作）。

### B樹的最佳化

B樹存在已久，多年來已開發出許多優化設計，包括：

- 使用寫時複製方案，例如LMDB，而非覆寫頁面並維護WAL以支援崩潰恢復。經修改的頁面被寫入不同位置，並在樹中建立父頁面的新版本以指向新位置。這種方法對於併發控制也很有用。
- 縮短鍵的大小，而非儲存整個鍵，以節省頁面空間。在樹內部的頁面上，鍵只需提供足夠的資訊來充當鍵範圍之間的邊界。在頁面中包含更多的鍵允許樹具有更高的分支因子，因此也就允許更少的層級。
- 不要求相鄰鍵範圍的頁面也放在硬碟上相鄰的區域，但這樣隨機存取的速度很慢。因此，許多B樹的實現在佈局樹時會盡量使葉子頁面按順序出現在硬碟上，但隨著樹的增長，要維持這個順序是很困難的。
- 新增指標到樹中，例如每個葉子頁面引用其左右兄弟頁面，使得不用跳回父頁面即可按順序掃描鍵。
- B樹的變體如分形樹借用了一些日誌結構的思想來減少硬碟查詢。

### 比較B樹和LSM樹

- 通常，LSM樹的寫入速度較快，B樹的讀取速度較快。
- LSM樹具有較高的寫入吞吐量，較低的寫放大和碎片，對固態硬碟較為友好。
- LSM樹可能在壓縮過程中干擾讀寫操作，且在高寫入吞吐量下壓縮性能受限
- B樹為許多工作負載提供了始終如一的良好效能，並適用於事務隔離等應用。

B樹和LSM樹的比較中，B樹實現通常較為成熟，但LSM樹在效能特徵方面也很有吸引力。經驗表明，LSM樹的寫入速度通常更快，而B樹的讀取速度更快。LSM樹上的讀取相對較慢，因為需要檢查多個資料結構和SSTables的不同壓縮層級。

然而，基準測試結果通常取決於工作負載細節，所以需要針對特定工作負載進行測試以進行有效比較。在評估儲存引擎效能時，需要考慮幾個因素。

LSM樹具有更高寫入吞吐量、較低的寫入放大和碎片化，並且可以將資料壓縮得更好，因此在硬碟上產生的檔案較小。不過，壓縮過程可能干擾到正在進行的讀寫操作，導致性能波動和較高的響應時間。在高寫入吞吐量下，壓縮性能可能受限，導致硬碟上未合併段的數量不斷增加，從而影響讀取速度。

B樹的優勢在於每個鍵在索引中只存在一個位置，並且通常具有較快的讀取速度。此外，B樹在需要強大事務語義的資料庫中非常適用，因為可以直接在B樹索引中的鍵範圍上應用鎖。然而，B樹可能具有更高的寫入放大和碎片化，導致磁碟空間使用增加和寫入吞吐量降低。

B樹在資料庫架構中具有深厚基礎，而LSM樹在新型資料庫中越來越受歡迎。要確定哪種儲存引擎最適合特定使用場景，需要根據實際工作負載進行測試。

### 其他索引結構

名詞解釋

1. 主鍵索引：在關聯式資料庫、文件資料庫或圖形資料庫中，主鍵唯一識別一行、一個文檔或一個頂點。其他紀錄可以通過主鍵（或ID）引用該行/文檔/頂點，索引用於解析這些引用。
2. 次級索引：允許在資料庫表格上建立額外的索引，以提高查詢性能。次要索引可以從鍵值索引構建，主要區別在於鍵不是唯一的。這可以通過使索引中的每個值成為匹配行標識符的列表或通過將行標識符附加到鍵上使其唯一來解決。
3. heap file：存儲行數據的無特定順序的文件。堆文件避免了多個次要索引存在時的數據重複問題：每個索引僅引用堆文件中的位置，實際數據存儲在一個地方。
4. Clustered 索引：將索引行直接存儲在索引中的一種方法，可以提高查詢性能。例如，MySQL的InnoDB存儲引擎中，表的主鍵始終是聚簇索引，次要索引引用主鍵（而不是堆文件位置）。
5. 包含列的索引：Clustered and non clustered index 的過渡，只保存部份需要用到的資料
6. 多列索引：同時查詢多個表列或文檔字段的索引。這對於需要根據多個條件查找數據的情況非常有用。
7. 串接索引：將多個字段組合成一個鍵的多列索引。串接索引的鍵是按照指定的順序將字段附加在一起的。它可以用來查找具有特定條件的所有數據，但如果只查詢其中一個字段，它可能無法提供幫助。
8. 多維索引：用於查詢多個列的一般方法，特別適用於地理空間數據。
9. R樹：專門用於地理空間數據的空間索引。
10. 全文搜索：用於模糊查詢的技術，支持對詞彙、語法變化和近義詞等進行搜索。

目前，我們只討論了鍵值索引，它們就像關係模型中的 **主鍵索引**。

次級索引（secondary indexes）也很常見。在關係資料庫中，你可以使用 `CREATE INDEX` 命令在同一個表上建立多個次級索引。

### 儲存Index 中的值

索引的鍵是查詢欄位，而值可以是行本身或是儲存在別處行的參照。後者儲存在 heap file 中

heap file 資料沒有特定順序，這種方法常見，因為可以避免在有多個次級 index 時複製資料。

Clustered Index 將整個資料列的所有資料存入索引中，查詢可直接在索引樹上完成，速度較快，但只能建立在唯一的鍵上。相反地，非聚集式 index 將索引資料存入索引樹中，而將資料列放置在另一個文件中，因此查詢需要先在索引樹上完成，再到文件中查詢資料列。

cover index 介於 clustered index and non clustered index 之間，包含查詢所需的所有欄位，可不必查詢表格本身即可回答查詢，因此可大幅提高查詢性能。

### 多列 index

又叫複合 index，對查詢有多種條件時，能加速，要注意 key 的順序是重要的，和下 where 欄位的順序一致的話，查詢是最快的。

### 多維 index

用於加速多維資料的查詢，例如帶有時間和地點兩個維度的天氣資料。它通常使用 R 樹資料結構來實現，具有高效的範圍查詢和空間查詢功能。在設計多維 index 時，必須仔細選擇索引的維度，以便在查詢時獲得最佳效能。

B 樹或 LSM 樹索引無法高效處理這種查詢：它可以返回一個經度範圍內的所有餐廳（但緯度可能是任意值），或者返回在同一緯度範圍內的所有餐廳（但經度可能是任意值），但不能同時滿足兩個條件。

### 全文搜尋和模糊索引

到目前為止所討論的所有索引都假定你有確切的資料，並允許你查詢鍵的確切值或具有排序順序的鍵的值範圍。他們不允許你做的是搜尋**類似**的鍵，如拼寫錯誤的單詞。這種模糊的查詢需要不同的技術，如全文搜尋引擎等。全文搜尋引擎允許用戶搜索相似的鍵，而不僅僅是確切的鍵值。

模糊索引（fuzzy indexes）類似於全文搜尋，但允許在查詢過程中包含近似匹配，以處理拼寫錯誤、拼音相似性等問題。為實現模糊索引，可以使用像Levenshtein距離、Damerau-Levenshtein距離和Jaro-Winkler距離等編輯距離度量，或使用如三元組或四元組的n-gram方法來度量相似性。

